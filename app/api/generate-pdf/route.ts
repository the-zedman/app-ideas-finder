import { NextResponse } from 'next/server';
import jsPDF from 'jspdf';

// Helper to clean text from HTML and markdown
const cleanText = (text: string): string => {
  if (!text) return '';
  return text
    .replace(/<[^>]*>/g, '') // Remove HTML tags
    .replace(/\*\*(.*?)\*\*/g, '$1') // Remove markdown bold
    .replace(/\*(.*?)\*/g, '$1') // Remove markdown italic
    .replace(/---/g, '') // Remove markdown separators
    .replace(/###\s*/g, '') // Remove markdown headings
    .replace(/##\s*/g, '')
    .replace(/#\s*/g, '')
    .replace(/\[(.*?)\]\(.*?\)/g, '$1') // Remove markdown links
    .trim();
};

// Helper to parse markdown content into formatted text
const parseMarkdownContent = (text: string): string[] => {
  if (!text) return [];
  
  const lines = text.split('\n');
  const result: string[] = [];
  
  lines.forEach((line) => {
    const cleaned = cleanText(line);
    if (cleaned.trim()) {
      // Handle bullet points
      if (cleaned.trim().startsWith('‚Ä¢') || cleaned.trim().startsWith('-') || cleaned.trim().startsWith('*')) {
        result.push(cleaned.trim());
      } else if (cleaned.trim().match(/^\d+\./)) {
        result.push(cleaned.trim());
      } else {
        result.push(cleaned);
      }
    }
  });
  
  return result;
};

export async function POST(request: Request) {
  try {
    const { appMeta, rollupContent, analysisMetrics } = await request.json();
    
    const doc = new jsPDF('p', 'mm', 'a4');
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    let yPosition = 20;
    
    // Helper function to add new page if needed
    const checkPageBreak = (neededSpace: number = 20) => {
      if (yPosition + neededSpace > pageHeight - 30) {
        doc.addPage();
        yPosition = 20;
        return true;
      }
      return false;
    };
    
    // Helper to add header on each page (except cover)
    const addHeader = () => {
      // Logo area
      doc.setFillColor(136, 209, 138); // #88D18A
      doc.rect(0, 0, pageWidth, 25, 'F');
      
      // Logo text (since we can't easily add images in server-side PDF)
      doc.setFontSize(16);
      doc.setTextColor(255, 255, 255);
      doc.setFont('helvetica', 'bold');
      doc.text('APP IDEAS FINDER', 20, 15);
      
      doc.setFontSize(8);
      doc.setFont('helvetica', 'normal');
      doc.text('www.appideasfinder.com', pageWidth - 20, 15, { align: 'right' });
      
      // Report title
      doc.setFontSize(10);
      doc.text('App Ideas Analysis Report', 20, 22);
      
      yPosition = 35;
    };
    
    // Helper to add footer on each page
    const addFooter = (pageNum: number, totalPages: number) => {
      const footerY = pageHeight - 10;
      doc.setFontSize(8);
      doc.setTextColor(150, 150, 150);
      doc.text('Generated by App Ideas Finder | www.appideasfinder.com', pageWidth / 2, footerY, { align: 'center' });
      doc.text(`Page ${pageNum} of ${totalPages}`, pageWidth - 20, footerY, { align: 'right' });
    };
    
    // === COVER PAGE ===
    // Header with logo area
    doc.setFillColor(136, 209, 138); // #88D18A
    doc.rect(0, 0, pageWidth, 50, 'F');
    
    doc.setFontSize(32);
    doc.setTextColor(255, 255, 255);
    doc.setFont('helvetica', 'bold');
    doc.text('APP IDEAS FINDER', pageWidth / 2, 25, { align: 'center' });
    
    doc.setFontSize(12);
    doc.setFont('helvetica', 'normal');
    doc.text('www.appideasfinder.com', pageWidth / 2, 35, { align: 'center' });
    
    // Report Title
    yPosition = 65;
    doc.setFontSize(20);
    doc.setTextColor(40, 40, 40);
    doc.setFont('helvetica', 'bold');
    doc.text('App Ideas Analysis Report', pageWidth / 2, yPosition, { align: 'center' });
    
    yPosition += 25;
    
    // App Details Box
    doc.setFillColor(250, 250, 250);
    doc.setDrawColor(200, 200, 200);
    doc.roundedRect(20, yPosition, pageWidth - 40, 60, 3, 3, 'FD');
    
    yPosition += 10;
    
    // App Name
    doc.setFontSize(18);
    doc.setTextColor(40, 40, 40);
    doc.setFont('helvetica', 'bold');
    const appName = appMeta?.trackName || 'Unknown App';
    const appNameLines = doc.splitTextToSize(appName, pageWidth - 80);
    doc.text(appNameLines, 30, yPosition);
    yPosition += appNameLines.length * 7 + 5;
    
    // App Icon placeholder (we'll add a note since we can't easily fetch images server-side)
    doc.setFontSize(9);
    doc.setTextColor(100, 100, 100);
    doc.setFont('helvetica', 'italic');
    doc.text('üì± App Icon', 30, yPosition);
    
    yPosition += 8;
    
    // App Details
    doc.setFontSize(10);
    doc.setTextColor(60, 60, 60);
    doc.setFont('helvetica', 'normal');
    doc.text(`Developer: ${appMeta?.artistName || 'Unknown'}`, 30, yPosition);
    yPosition += 6;
    
    const rating = appMeta?.averageUserRating?.toFixed(1) || 'N/A';
    const ratingCount = appMeta?.userRatingCount?.toLocaleString() || '0';
    doc.text(`Rating: ${rating} ‚òÖ (${ratingCount} ratings)`, 30, yPosition);
    yPosition += 6;
    
    doc.text(`Reviews Analyzed: ${analysisMetrics?.reviewCount?.toLocaleString() || 0}`, 30, yPosition);
    yPosition += 6;
    
    doc.text(`Analysis Date: ${new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}`, 30, yPosition);
    
    // Summary Box
    yPosition += 20;
    doc.setFillColor(240, 250, 245);
    doc.setDrawColor(136, 209, 138);
    doc.roundedRect(20, yPosition, pageWidth - 40, 30, 3, 3, 'FD');
    
    yPosition += 8;
    doc.setFontSize(10);
    doc.setTextColor(60, 60, 60);
    doc.setFont('helvetica', 'normal');
    const summaryText = 'This comprehensive 13-section analysis provides actionable insights for building a successful app based on real user feedback from the App Store.';
    const splitSummary = doc.splitTextToSize(summaryText, pageWidth - 50);
    doc.text(splitSummary, 25, yPosition);
    
    // === SECTIONS START ===
    doc.addPage();
    addHeader();
    
    const sections = [
      { key: 'likes', title: '1. What People Like About the TARGET App', icon: 'üëç' },
      { key: 'dislikes', title: "2. What Users Want (and Don't Want) from the TARGET App", icon: 'üí≠' },
      { key: 'keywords', title: '3. Suggested Keywords for Your New App', icon: 'üîç' },
      { key: 'definitely', title: '4. Core Features to Include in Your New App', icon: 'üéØ' },
      { key: 'backlog', title: '5. New and Additional Features to Include in Your New App', icon: '‚ú®' },
      { key: 'recommendations', title: '6. Strategic Recommendations & Insights for Your New App', icon: '‚≠ê' },
      { key: 'description', title: '7. Suggested Description for Your New App', icon: 'üìù' },
      { key: 'names', title: '8. Suggested Names for Your New App', icon: 'üí°' },
      { key: 'prp', title: '9. PRP (Product Requirements Prompt) for Your New App', icon: 'üìã' },
      { key: 'similar', title: '10. Similar Apps', icon: 'üì±' },
      { key: 'pricing', title: '11. Pricing Strategy & Revenue Projections for Your New App', icon: 'üí∞' },
      { key: 'viability', title: '12. Market Viability & Business Opportunity Analysis for Your New App', icon: 'üìä' },
    ];
    
    sections.forEach((section, index) => {
      const content = rollupContent[section.key];
      if (!content || content.length === 0) return;
      
      checkPageBreak(35);
      
      // Section Header
      doc.setFillColor(136, 209, 138);
      doc.roundedRect(20, yPosition, pageWidth - 40, 10, 2, 2, 'F');
      
      doc.setFontSize(13);
      doc.setTextColor(255, 255, 255);
      doc.setFont('helvetica', 'bold');
      doc.text(`${section.icon} ${section.title}`, 25, yPosition + 7);
      
      yPosition += 15;
      
      // Section Content
      doc.setFontSize(10);
      doc.setTextColor(60, 60, 60);
      doc.setFont('helvetica', 'normal');
      
      if (section.key === 'keywords' || section.key === 'names') {
        // Display as comma-separated tags
        const tags = Array.isArray(content) ? content : [];
        const tagText = tags.join(', ');
        const splitText = doc.splitTextToSize(tagText, pageWidth - 50);
        doc.text(splitText, 25, yPosition);
        yPosition += splitText.length * 5 + 10;
        
      } else if (section.key === 'backlog') {
        // Display with priorities
        const items = Array.isArray(content) ? content : [];
        items.forEach((item: any) => {
          checkPageBreak(20);
          const priority = item.priority || 'Low';
          const priorityColor: [number, number, number] = 
            priority === 'High' ? [220, 53, 69] : 
            priority === 'Medium' ? [255, 193, 7] : 
            [40, 167, 69];
          
          doc.setTextColor(priorityColor[0], priorityColor[1], priorityColor[2]);
          doc.setFont('helvetica', 'bold');
          doc.text(`[${priority} Priority]`, 25, yPosition);
          
          doc.setTextColor(60, 60, 60);
          doc.setFont('helvetica', 'normal');
          const contentText = doc.splitTextToSize(item.content || '', pageWidth - 55);
          doc.text(contentText, 25, yPosition + 5);
          yPosition += contentText.length * 5 + 8;
        });
        
      } else if (section.key === 'similar') {
        // Display similar apps as cards
        const apps = Array.isArray(content) ? content : [];
        apps.slice(0, 9).forEach((app: any, idx: number) => {
          checkPageBreak(25);
          
          // Card background
          doc.setFillColor(250, 250, 250);
          doc.setDrawColor(220, 220, 220);
          doc.roundedRect(25, yPosition, pageWidth - 50, 20, 2, 2, 'FD');
          
          // App icon placeholder
          doc.setFontSize(8);
          doc.setTextColor(150, 150, 150);
          doc.text('üì±', 28, yPosition + 8);
          
          // App name
          doc.setFontSize(11);
          doc.setTextColor(40, 40, 40);
          doc.setFont('helvetica', 'bold');
          const appName = app.trackName || 'Unknown App';
          const appNameLines = doc.splitTextToSize(appName, pageWidth - 80);
          doc.text(appNameLines, 35, yPosition + 6);
          
          // Developer
          doc.setFontSize(9);
          doc.setFont('helvetica', 'normal');
          doc.setTextColor(100, 100, 100);
          doc.text(app.artistName || 'Unknown Developer', 35, yPosition + 12);
          
          // Rating and price
          const rating = app.averageUserRating?.toFixed(1) || 'N/A';
          const ratingCount = app.userRatingCount?.toLocaleString() || '0';
          const price = app.formattedPrice || 'Free';
          doc.text(`‚òÖ ${rating} (${ratingCount}) ‚Ä¢ ${price}`, 35, yPosition + 17);
          
          yPosition += 25;
        });
        
      } else if (section.key === 'prp' || section.key === 'pricing' || section.key === 'description' || section.key === 'viability') {
        // Long form content - parse markdown properly
        const text = Array.isArray(content) ? content[0] : content;
        if (text) {
          const parsedLines = parseMarkdownContent(text);
          
          parsedLines.forEach((line: string) => {
            checkPageBreak(10);
            
            // Handle headings
            if (line.match(/^[A-Z][A-Z\s]+$/)) {
              doc.setFontSize(11);
              doc.setFont('helvetica', 'bold');
              doc.setTextColor(40, 40, 40);
              doc.text(line, 25, yPosition);
              yPosition += 7;
            } else {
              // Regular text
              doc.setFontSize(10);
              doc.setFont('helvetica', 'normal');
              doc.setTextColor(60, 60, 60);
              const splitLine = doc.splitTextToSize(line, pageWidth - 50);
              doc.text(splitLine, 25, yPosition);
              yPosition += splitLine.length * 5;
            }
          });
          yPosition += 5;
        }
        
      } else {
        // Regular bullet lists
        const items = Array.isArray(content) ? content : [];
        items.forEach((item: string) => {
          checkPageBreak(12);
          const cleanItem = cleanText(item);
          const splitItem = doc.splitTextToSize(`‚Ä¢ ${cleanItem}`, pageWidth - 55);
          doc.text(splitItem, 25, yPosition);
          yPosition += splitItem.length * 5 + 2;
        });
      }
      
      yPosition += 8;
    });
    
    // === TIME & COST SAVINGS (Section 13) ===
    if (analysisMetrics?.reviewCount > 0) {
      checkPageBreak(30);
      
      doc.setFillColor(136, 209, 138);
      doc.roundedRect(20, yPosition, pageWidth - 40, 10, 2, 2, 'F');
      doc.setFontSize(13);
      doc.setTextColor(255, 255, 255);
      doc.setFont('helvetica', 'bold');
      doc.text('‚è±Ô∏è 13. Time & Cost Savings Analysis', 25, yPosition + 7);
      
      yPosition += 15;
      doc.setFontSize(10);
      doc.setTextColor(60, 60, 60);
      doc.setFont('helvetica', 'normal');
      doc.text(`AI Analysis completed in seconds, saving significant time and cost compared to manual analysis.`, 25, yPosition);
      yPosition += 10;
      
      if (analysisMetrics?.manualTaskHours) {
        doc.text(`Estimated manual analysis time: ${analysisMetrics.manualTaskHours.toFixed(1)} hours`, 25, yPosition);
      }
    }
    
    // Add header and footer to all pages
    const totalPages = doc.getNumberOfPages();
    for (let i = 2; i <= totalPages; i++) {
      doc.setPage(i);
      addHeader();
      addFooter(i, totalPages);
    }
    
    // Add footer to cover page
    doc.setPage(1);
    addFooter(1, totalPages);
    
    // Generate PDF as buffer
    const pdfBuffer = Buffer.from(doc.output('arraybuffer'));
    
    return new NextResponse(pdfBuffer, {
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="app-analysis-${appMeta?.trackName?.replace(/[^a-z0-9]/gi, '-') || 'report'}.pdf"`,
      },
    });
    
  } catch (error) {
    console.error('PDF generation error:', error);
    return NextResponse.json({ error: 'Failed to generate PDF' }, { status: 500 });
  }
}
